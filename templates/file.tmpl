{{- define "File" -}}
// Code generated by protoc-gen-defaults. DO NOT EDIT.

package {{ .PackageName }}

import (
	"context"
	"errors"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
	"go.uber.org/zap"
	"github.com/golang/protobuf/ptypes"
	"github.com/golang/protobuf/ptypes/empty"
	events "github.com/ayushbpl10/protoc-gen-events/eventspush/pb"
	"go.saastack.io/userinfo"
	pushglobal "go.saastack.io/deployment/events"
{{ range .Imports }}
    "{{ .}}"
{{ end }}
)

{{ range $service := .Services }}

    const (
	    {{ range $rpc := $service.Rpcs }}
	        {{if eq $rpc.Push true}}
	        EVENT_{{$service.ServiceName}}_{{$rpc.RpcName}} pushglobal.NotificationEvent = "{{$rpc.Protopath}}"
	        {{end}}
	    {{ end }}
	)

	/*
	Receiving usage :

	switch (NotificationEvent(event.Type)){
	        {{ range $rpc := $service.Rpcs }}
	        {{if eq $rpc.Push true}}case EVENT_{{$service.ServiceName}}_{{$rpc.RpcName}} :{{end}}{{ end }}
	        }
	*/


    type events{{$service.ServiceName}}Server struct {
        {{$service.ServiceName}}Server
        eventsCli events.EventValidatorsClient
    }

    func NewEvents{{$service.ServiceName}}Server(
    	c events.EventValidatorsClient,
    	srv {{$service.ServiceName}}Server,
	) {{$service.ServiceName}}Server {
        return &events{{$service.ServiceName}}Server{
            srv,
            c,
        }
    }

    {{ range $rpc := $service.Rpcs }}
        func (s *events{{$service.ServiceName}}Server) {{$rpc.RpcName}}(ctx context.Context, req {{if eq $rpc.Input "Empty"}}*empty.{{$rpc.Input}}{{else}}*{{$rpc.Input}}{{end}}) ({{if eq $rpc.Output "Empty"}}*empty.{{$rpc.Output}}{{else}}*{{$rpc.Output}}{{end}}, error) {

            res, err := s.{{$service.ServiceName}}Server.{{.RpcName}}(ctx, req)
            if err != nil{
                return nil, err
            }

            {{if eq $rpc.Push true}}

				reqData, err := ptypes.MarshalAny(req)
                if err != nil {
                    ctxzap.Extract(ctx).Error("Could not create event object", zap.Any("request", req), zap.Any("response", res), zap.Error(err))
                    return res, nil
                }

                resData, err := ptypes.MarshalAny(res)
                if err != nil {
                    ctxzap.Extract(ctx).Error("Could not create event object", zap.Any("request", req), zap.Any("response", res), zap.Error(err))
                    return res, nil
                }

                userInfo := userinfo.FromContext(ctx)
                event := events.Event{
                    Type:          string(EVENT_{{$service.ServiceName}}_{{$rpc.RpcName}}),
                    Request:       reqData,
                    Response:      resData,
                    RaisedOn:      ptypes.TimestampNow(),
                    RaisedBy:      userInfo.Id,
                    RaisedByEmail: userInfo.Email,
                }

                if _, err = s.eventsCli.Push(ctx, &event); err != nil {
                    ctxzap.Extract(ctx).Error("Could not push event", zap.Any("event", event), zap.Error(err))
                }

            {{ end }}

            return res, nil

        }
        {{if eq $rpc.Push true}}
        func EVENT_{{$service.ServiceName}}_{{$rpc.RpcName}}_Unmarshal(event *events.Event) ({{if eq $rpc.Input "Empty"}}*empty.{{$rpc.Input}}{{else}}*{{$rpc.Input}}{{end}},{{if eq $rpc.Output "Empty"}}*empty.{{$rpc.Output}}{{else}}*{{$rpc.Output}}{{end}}, error){
        	if event.Type != string(EVENT_{{$service.ServiceName}}_{{$rpc.RpcName}}) {
            		return nil,nil,errors.New("Wrong event type: Expected EVENT_{{$service.ServiceName}}_{{$rpc.RpcName}} ")
            }

        	var requestObj {{if eq $rpc.Input "Empty"}}empty.{{$rpc.Input}}{{else}}{{$rpc.Input}}{{end}}
        	if err := ptypes.UnmarshalAny(event.Request, &requestObj); err != nil {
        		return nil,nil,err
        	}

        	var responseObj {{if eq $rpc.Output "Empty"}}empty.{{$rpc.Output}}{{else}}{{$rpc.Output}}{{end}}
            if err := ptypes.UnmarshalAny(event.Response, &responseObj); err != nil {
                return nil, nil, err
            }

            return &requestObj, &responseObj, nil
        }
        {{end}}


    {{end}}
{{ end }}

{{end}}
